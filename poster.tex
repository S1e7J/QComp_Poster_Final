% Unofficial University of Cambridge Poster Template
% https://github.com/andiac/gemini-cam
% a fork of https://github.com/anishathalye/gemini
% also refer to https://github.com/k4rtik/uchicago-poster

\documentclass[final]{beamer}

% ====================
% Packages
% ====================

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[orientation=portrait,size=a0,scale=1.17]{beamerposter}
\usetheme{gemini}
\usecolortheme{nott}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{quantikz}
\usepackage{braket}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.14}
\usepackage{anyfontsize}

% ====================
% Lengths
% ====================

% If you have N columns, choose \sepwidth and \colwidth such that
% (N+1)*\sepwidth + N*\colwidth = \paperwidth
\newlength{\sepwidth}
\newlength{\colwidth}
\setlength{\sepwidth}{0.025\paperwidth}
\setlength{\colwidth}{0.45\paperwidth}

\newcommand{\separatorcolumn}{\begin{column}{\sepwidth}\end{column}}

  % ====================
  % Title
  % ====================

  \title{Bases de corrección cuantica de errores}

  \author{Sergio Montoya Ramirez \inst{1} \and Kenneth Alejandro Rodriguez Peña \inst{1}}

  \institute[shortinst]{\inst{1} Univerisad de los Andes}

  % ====================
  % Footer (optional)
  % ====================

  % \footercontent{
  %   \href{https://www.example.com}{https://www.example.com} \hfill
  %   ABC Conference 2025, New York --- XYZ-1234 \hfill
  %   \href{mailto:agajan.torayev@example.com}{agajan.torayev@example.com}}
  % (can be left out to remove footer)


  % ====================
  % Logo (optional)
  % ====================

  % use this to include logos on the left and/or right side of the header:
  \logoright{\includegraphics[height=7cm]{./logos/logo-uniandes.png}}
  %\logoleft{\includegraphics[height=7cm]{logos/UoN_Logo_NottinghamBlue_WhiteText_CMYK.pdf}}

  % ====================
  % Body
  % ====================

  \begin{document}

  % Refer to https://github.com/k4rtik/uchicago-poster
  % logo: https://www.cam.ac.uk/brand-resources/about-the-logo/logo-downloads
  % \addtobeamertemplate{headline}{}
  % {
  %     \begin{tikzpicture}[remember picture,overlay]
  %       \node [anchor=north west, inner sep=3cm] at ([xshift=-2.5cm,yshift=1.75cm]current page.north west)
  %       {\includegraphics[height=7cm]{logos/unott-logo.eps}}; 
  %     \end{tikzpicture}
  % }

  \begin{frame}[t]
    \begin{columns}[t]
      \separatorcolumn

      \begin{column}{\colwidth}

        \begin{block}{Introducción}
          La computación cuántica enfrenta un reto fundamental con los qubits físicos, pues son extremadamente sensibles al ruido y al entorno (por su naturaleza cuántica), lo que genera errores incluso antes de realizar operaciones lógicas. Así mismo, el teorema de no clonación impide aplicar estrategias clásicas de correción de errores sobre los qubits. 
          Es de esta manera, que Shor (1995) y Calderbank–Shor–Steane (1996) introdujeron los primeros códigos de corrección cuántica, basados en distribuir la información de un qubit en varios qubits físicos y detectar qué error ocurrió sin medir directamente el estado lógico.

          En este trabajo se resumirán los elementos básicos de la corrección cuántica: ejemplos simples,
          fundamentos matemáticos y códigos estabilizadores como los de Shor y CSS.
        \end{block}

        \begin{block}{Ejemplo: Phase Flip}

          El canal de \textit{phase flip} consiste en invertir la fase del qubit con una probabilidad $p$ de que ocurra. Para corregirlo, se propone un código de tres qubits con estados lógicos

          \[
            |0_L\rangle = |000\rangle , \qquad |1_L\rangle = |111\rangle .
          \]

          Si un error ocurre en uno de los tres qubits, medimos operadores que identifican cuál fue afectado sin destruir la información lógica. Esto permite aplicar $X$ en el qubit correcto para recuperar el estado original, lo cual se consigue con operadores estabilizadores:

          \begin{align*}
            P_{0} &\equiv \ket{000}\bra{000} + \ket{111}\bra{111},\\
            P_{1} &\equiv \ket{100}\bra{100} + \ket{011}\bra{011},\\
            P_{2} &\equiv \ket{010}\bra{010} + \ket{101}\bra{101},\\
            P_{3} &\equiv \ket{001}\bra{001} + \ket{110}\bra{110}.
          \end{align*}

        \end{block}

        \begin{block}{Formalismos}
          \heading{Codigo}
          Sea $\mathcal{L}$ un espacio de tamaño fijo, decimos que $\mathcal{M}$ un subespacio de algun espacio $\qubitset{B}^n$ es un codigo que codifica $\mathcal{L}$ si existe una operación $\mathcal{V}: \mathcal{L} \to \mathcal{M}$ que se le conoce como codificador.

          \heading{Codigo que corrige errores}

          Sea $C$ un codigo y $\mathcal{E}$ un procedimiento que define un error. Decimos que $C$ corrige $\mathcal{E}$ si existe un procedimiento $\mathcal{R}$ tal que

          \begin{equation}
            \forall p \in C : (\mathcal{R} \circ \mathcal{E}) (p) \propto p
            \label{eq:corrects}
          \end{equation}

          Una nota importante que ver es que el $\propto$ nos representa que realmente la operación de recuperación no nos devuelve exactamente al qubit original. Sin embargo, si nos debe devolver a un qubit que codifique la misma información que el anterior.

          \heading{Condiciones para que un Codigo Corriga un error}

          Sea $C$ un codigo y $P$ el proyector a $C$. Suponga que $\mathcal{E}$ es una operación cuantica con elementos $\left\{E_i \right\}$. Una condición necesaria y suficiente para que exista una operación $\mathcal{R}$ que corrija $\mathcal{E}$ en $C$ es
          \begin{equation}
            PE_i^{\dagger} E_jP = \alpha_{ij}P
            \label{eq:conditions}
          \end{equation}

          para alguna matriz hermitica $\alpha$ de numeros complejos.

          \heading{Cota de Hamming}

          Sea $C$ un codigo que codifica $k$ qubits en $n$ qubits y que puede corregir cualquier subconjunto de $t$ errores. Particularmente, asuma sin perdida de generalidad que corrige $j \le t$ errores. Entonces se cumple la cota [1]
          \begin{equation}
            \sum_{j = 0}^{t} \binom{n}{j} 3^j 2^k \le 2^n
            \label{eq:hamming_bound}
          \end{equation}

          \heading{Estabilizadores}
          Las bases del formalismo de estabilizadores consiste en mirar un estado no desde sus caracteristicas si no desde los operadores que lo estabilizan. Un operador se dice que estabiliza a un estado si el estado es un eigenvector con eigenvalue $+1$. Es decir, $S$ estabiliza $\ket{\psi}$ si $s\ket{\psi} = \ket{\psi}$[1].

          Una de las caracteristicas mas importantes es que al definir de esta manera un estado estamos construyendo grupos y por tanto podemos usar teoria de grupos para realizar las interpretaciones de los diversos codigos. Esto es parte de lo que hace tan increiblemente fuerte el formalismo de estabilizadores y lo que nos va a permitir hablar de los siguientes codigos que usan este formalismo.
        \end{block}

      \end{column}

      \separatorcolumn

      \begin{column}{\colwidth}

        \begin{exampleblock}{Codigo de Shor}

          Este fue uno de los primeros códigos de corrección de errores, diseñado por Shor en 1995 en el artículo \textit{Scheme for reducing decoherence in quantum computer memory}. Este código permite corregir errores arbitrarios en un solo qubit.

          El código se define mediante el circuito que puede verse en la figura, transformando $\ket{0} \to \ket{+++}$ y $\ket{1} \to \ket{---}$. La operación de recuperación se divide en dos partes:

          \begin{enumerate}
            \item Determinar el qubit afectado. Aquí resulta crucial que este código sea estabilizador, ya que utilizamos sus operadores para identificar el qubit donde ocurrió el error.
            \item Una vez identificado el qubit erróneo, se procede a corregirlo. La corrección es un término genérico, ya que este código corrige errores arbitrarios.
          \end{enumerate}

          \begin{center}
            \scalebox{1.5}{
              \begin{quantikz}[row sep=1cm, column sep=1cm]
                \lstick{$\ket{\psi}$} & \ctrl{3} & \ctrl{6} & \gate{H} & \qw & \ctrl{1} & \ctrl{2} & \qw \\
                &&&& \lstick{$\ket{0}$} & \targ{} & \qw & \qw \\
                &&&& \lstick{$\ket{0}$} & \qw & \targ{} & \qw \\
                \lstick{$\ket{0}$} & \targ{} & \qw & \gate{H}& \qw & \ctrl{1} & \ctrl{2} & \qw\\
                &&&& \lstick{$\ket{0}$} & \targ{} & \qw & \qw \\
                &&&& \lstick{$\ket{0}$} & \qw & \targ{} & \qw \\
                \lstick{$\ket{0}$} & \qw & \targ{} & \gate{H} & \qw & \ctrl{1} & \ctrl{2} & \qw\\
                &&&& \lstick{$\ket{0}$} & \targ{} & \qw & \qw \\
                &&&& \lstick{$\ket{0}$} & \qw & \targ{} & \qw
              \end{quantikz}
            }
          \end{center}

          \heading{¿Por que puede corregir errores arbitrarios?}

          Supongamos que tenemos un error $\mathcal{E}$ con elementos $\left\{E_i\right\}$, de modo que para el estado $\ket{\psi} = a \ket{0_L} + b \ket{1_L}$ se cumple:  
          \[\mathcal{E}(\ket{\psi}\bra{\psi}) = \sum_{i} E_i\ket{\psi}\bra{\psi}E_i^\dagger.\]  
          Ahora bien, sabemos que cualquier $E_i$ puede escribirse como una combinación lineal de la forma:  
          \[E_i = e_{i0} I + e_{i1} X_j + e_{i2} Z_j + e_{i3} X_j Z_j,\]  
          donde $j$ es el número del qubit en el que ocurre el error. Esto nos proporciona el elemento invertible necesario para corregir un error arbitrario. Cabe aclarar que este resultado supone que los errores actúan de manera independiente entre qubits, lo cual es una aproximación razonable, aunque existen condiciones en las que esta suposición no se cumple. En tales casos, es preferible utilizar un código que corrija errores en más de un qubit, como, por ejemplo, algunos códigos de la familia CSS.
        \end{exampleblock}

        \begin{exampleblock}{Codigos CSS}
          los códigos CSS (calderbank-shor-steane) son un subconjunto de los códigos estabilizadores. informalmente, permiten construir códigos que corrigen los mismos errores a partir de dos códigos existentes, utilizando menos qubits para la codificación.

          Sean $c_1$ y $c_2$ códigos lineales $[n, k_1]$ y $[n, k_2]$ (cerrados bajo suma módulo 2) tales que:
          \begin{itemize}
            \item $c_2 \subset c_1$,
            \item $c_1$ y $c_2^\perp$ corrigen $t$ errores.
          \end{itemize}
          definimos el código css de $c_1$ sobre $c_2$ como el código $[n, k_1 - k_2]$ denotado por $css(c_1, c_2)$ mediante el siguiente procedimiento. sea $x \in c_1$, entonces definimos el estado:
          \[\ket{x + c_2} = \frac{1}{\sqrt{\left|c_2\right|}} \sum_{y \in c_2} \ket{x + y} \]
          donde $+$ denota suma módulo 2. nótese que si $x' \in c_1$ y $x - x' \in c_2$, entonces $\ket{x + c_2} = \ket{x' + c_2}$. el código $css(c_1, c_2)$ corresponde al espacio generado por los estados $\ket{x + c_2}$, los cuales forman un conjunto ortonormal[1].

          la ventaja de esta construcción es evidente: si encontramos un subcódigo que corrija los mismos $t$ errores, podemos reducir considerablemente el tamaño del código original. un ejemplo notable de código css es el código de shor.

        \end{exampleblock}

        \begin{block}{References}

          \nocite{*}
          \footnotesize{\bibliographystyle{plain}\bibliography{poster}}

        \end{block}

      \end{column}
      \separatorcolumn



    \end{columns}
  \end{frame}

\end{document}
